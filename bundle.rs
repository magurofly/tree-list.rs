use __cargo_equip::prelude::*;#[doc="  # Bundled libraries"]#[doc=" "]#[doc="  - `tree-list 0.1.0 (path+█████████████████████████████)` published in **missing** licensed under `CC0-1.0` as `crate::__cargo_equip::crates::tree_list`"]#[allow(unused)]mod __cargo_equip{pub(crate)mod crates{pub mod tree_list{pub mod node{use std::{pin::Pin};pub type PinnedNode<T> =Pin<Box<Node<T>>>;pub struct Node<T>{data:T,len:usize,height:usize,children:[Option<PinnedNode<T>>;2]}impl<T>Node<T>{pub fn new(data:T)->Self{Node{data,len:1,height:1,children:[None,None]}}pub fn from_iter<I:IntoIterator<Item=T>>(data:I)->Option<Pin<Box<Self>>>{let mut node=None;for element in data{node=Node::merge(node,Some(Node::pin(element)));}node}pub fn pin(data:T)->Pin<Box<Self>>{Box::pin(Self::new(data))}pub fn len(&self)->usize{self.len}pub fn data(&self)->&T{&self.data}pub fn data_mut(&mut self)->&mut T{&mut self.data}pub fn into_data(self)->T{self.data}pub fn child(&self,dir:bool)->Option<&Node<T>>{if let Some(child)=&self.children[dir as usize]{Some(child.as_ref().get_ref())}else{None}}pub fn at(&self,index:usize)->&Self{let mut left_len=0;if let Some(left)=&self.children[0]{left_len=left.len();if index<left_len{return left.at(index);}}if index==left_len{return self;}self.children[1].as_ref().unwrap().at(index-left_len-1)}pub fn at_mut(&mut self,index:usize)->&mut Self{let left_len=self.children[0].as_ref().map(|node|node.len()).unwrap_or(0);if index<left_len{unsafe{self.children[0].as_mut().unwrap().as_mut().get_unchecked_mut()}.at_mut(index)}else if index==left_len{self}else{unsafe{self.children[1].as_mut().unwrap().as_mut().get_unchecked_mut()}.at_mut(index-left_len-1)}}pub fn rotate(mut self:Pin<Box<Self>>,dir:bool)->Pin<Box<Self>>{let self_mut=unsafe{self.as_mut().get_unchecked_mut()};if let Some(mut child)=self_mut.children[!dir as usize].take(){let child_mut=unsafe{child.as_mut().get_unchecked_mut()};self_mut.children[!dir as usize]=child_mut.children[dir as usize].take();self_mut.update();child_mut.children[dir as usize]=Some(self);child_mut.update();child}else{self}}pub fn balance(self:Pin<Box<Self>>)->Pin<Box<Self>>{let lh=self.children[0].as_ref().map(|child|child.height).unwrap_or(0);let rh=self.children[1].as_ref().map(|child|child.height).unwrap_or(0);if lh+2<rh{self.rotate(false)}else if rh+2<lh{self.rotate(true)}else{self}}pub fn update(&mut self){let mut len=1;let mut height=1;for child in&self.children{if let Some(child)=child{len+=child.len;height=height.max(child.height+1);}}self.len=len;self.height=height;}pub fn merge(left:Option<Pin<Box<Self>>>,right:Option<Pin<Box<Self>>>)->Option<Pin<Box<Self>>>{if let Some(left)=left{if let Some(right)=right{Some(left.append(right))}else{Some(left)}}else{right}}pub fn append(mut self:Pin<Box<Self>>,other:Pin<Box<Self>>)->Pin<Box<Self>>{let self_mut=unsafe{self.as_mut().get_unchecked_mut()};let right=&mut self_mut.children[1];*right=Some(if let Some(child)=right.take(){child.append(other)}else{other});self_mut.update();self.balance()}pub fn split_at(mut self:Pin<Box<Self>>,at:usize)->(Option<Pin<Box<Self>>>,Option<Pin<Box<Self>>>){assert!(at<=self.len);if at==0{(None,Some(self))}else if at==self.len{(Some(self),None)}else{let mut left_len=0;if let Some(left_child)=&self.children[0]{left_len=left_child.len;let self_mut=unsafe{self.as_mut().get_unchecked_mut()};if at<=left_len{let(left,right)=self_mut.children[0].take().unwrap().split_at(at);self_mut.children[0]=right;self_mut.update();return(left,Some(self.balance()));}}let self_mut=unsafe{self.as_mut().get_unchecked_mut()};let(left,right)=self_mut.children[1].take().unwrap().split_at(at-left_len-1);self_mut.children[1]=left;self_mut.update();(Some(self.balance()),right)}}}}pub mod iter{use super::*;pub struct Iter<'a,T>{stack:Vec<&'a Node<T>>,}impl<'a,T>Iter<'a,T>{pub fn new(root:Option<&'a Node<T>>)->Self{let mut this=Self{stack:vec![]};this.add(root);this}fn add(&mut self,mut node:Option<&'a Node<T>>){while let Some(child)=node{self.stack.push(child);node=child.child(false);}}}impl<'a,T>Iterator for Iter<'a,T>{type Item=&'a T;fn next(&mut self)->Option<Self::Item>{let node=self.stack.pop()?;let element=node.data();self.add(node.child(true));Some(element)}}}use std::{ops::*,pin::Pin,iter::FromIterator,fmt::Debug};use node::*;pub struct TreeList<T>{root:Option<PinnedNode<T>>,}impl<T>TreeList<T>{pub fn new()->Self{Self{root:None,}}pub fn raw(root:Option<PinnedNode<T>>)->Self{Self{root,}}pub fn len(&self)->usize{self.root.as_ref().map(|node|node.len()).unwrap_or(0)}pub fn is_empty(&self)->bool{self.len()==0}pub fn clear(&mut self){self.root=None;}pub fn insert(&mut self,index:usize,element:T){assert!(index<=self.len());let node=Node::pin(element);if let Some(root)=self.root.take(){let(left,right)=root.split_at(index);self.root=Node::merge(Node::merge(left,Some(node)),right);}else{self.root=Some(node);}}pub fn push_front(&mut self,element:T){let node=Node::pin(element);self.root=Node::merge(Some(node),self.root.take());}pub fn push_back(&mut self,element:T){let node=Node::pin(element);self.root=Node::merge(self.root.take(),Some(node));}pub fn append(&mut self,other:&mut Self){self.root=Node::merge(self.root.take(),other.root.take());}pub fn remove(&mut self,index:usize)->Option<T>{assert!(index<self.len());let(left,right)=self.root.take()?.split_at(index);if let Some(right)=right{let(node,right)=right.split_at(1);self.root=Node::merge(left,right);return Some(unsafe{Pin::into_inner_unchecked(node?)}.into_data());}else{self.root=left;return None;}}pub fn pop_front(&mut self)->Option<T>{let(left,right)=self.root.take()?.split_at(1);self.root=right;Some(unsafe{Pin::into_inner_unchecked(left?)}.into_data())}pub fn pop_back(&mut self)->Option<T>{let root=self.root.take()?;let index=root.len()-1;let(left,right)=root.split_at(index);self.root=left;Some(unsafe{Pin::into_inner_unchecked(right?)}.into_data())}pub fn split_off(&mut self,at:usize)->Self{assert!(at<=self.len());if let Some(root)=self.root.take(){let(left,right)=root.split_at(at);self.root=left;Self::raw(right)}else{Self::new()}}pub fn iter(&self)->iter::Iter<'_,T>{iter::Iter::new(self.root.as_ref().map(|node|node.as_ref().get_ref()))}}impl<T>FromIterator<T>for TreeList<T>{fn from_iter<I:IntoIterator<Item=T>>(iter:I)->Self{Self::raw(Node::from_iter(iter))}}impl<T>Index<usize>for TreeList<T>{type Output=T;fn index(&self,index:usize)->&T{assert!(index<self.len());self.root.as_ref().unwrap().at(index).data()}}impl<T>IndexMut<usize>for TreeList<T>{fn index_mut(&mut self,index:usize)->&mut T{assert!(index<self.len());unsafe{self.root.as_mut().unwrap().as_mut().get_unchecked_mut()}.at_mut(index).data_mut()}}impl<T:Debug>Debug for TreeList<T>{fn fmt(&self,f:&mut std::fmt::Formatter<'_>)->std::fmt::Result{f.write_str("TreeList {")?;let mut first=true;for element in self.iter(){if!first{f.write_str(", ")?;}first=false;f.write_fmt(format_args!("{:?}",element))?;}f.write_str("}")?;Ok(())}}}}pub(crate)mod macros{pub mod tree_list{}}pub(crate)mod prelude{pub use crate::__cargo_equip::crates::tree_list;}mod preludes{pub mod tree_list{}}}